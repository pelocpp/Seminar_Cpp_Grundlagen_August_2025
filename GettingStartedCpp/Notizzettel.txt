C++ Grundlagen

Peter Loos

================

12.30: 

Kaffeepause

17.00 

Übungen:   Nachmittagsstunden ....

================

ToDo:
=====

== Vererbung

== Templates

== STL // Container // Iteratoren ... Wichtig 








================


Background:

C/C++ ... Java ... C# ...JavaScript ... 

Python wenig (zeitlich)

Back to the Roots: C/C++ (Nachfrage)

================

Erwartungen

== C++ kennen und anwenden 
== C++ Programme schreiben können
== C++ vertiefen
== C++ Programme lesen können
== .......................

== Tiefer in das OOP
== Architektur
== Embedded-Bereich
== Speicherverwaltung

== C++ 11 / 17 and beyond: Da kann ich gerne am Ende
               einen 2-4 stündigen Überblick geben.


== Classic C++ :  Vom ersten Tag an ... BIS C++ 11

   Fundament in C++

== Modern C++:    C++ 11 bis heute (C++ 23 / 26)

================

Online-Seminar:

a) Tool: Visual Studio

b) Unterlagen:  Github:  

https://github.com/pelocpp

Classic C++:

https://github.com/pelocpp/cpp_introduction

================

Hinweis:

C ist in C++ enthalten (99%)

C-Kenntnisse sind vorhanden (for, if, ...)

================

Jederzeit / Zwischendrin: 

Fazit // langsamer // schneller // Passd scho


================

VS Code: 

Installation von Gcc // MinGW (GCC) etc. // Extensions selber machen.


================

Namensraum:  

std::cout

Ich will ein Objekt cout benennen:

================

Übersetzung eines C/C++ Programms:

C++:  Übersetzungseinheit: Eine C++ - Datei (keine Header-Datei)

== Präprozessor (Tool, um #-Direktiven aufzulösen)

== C/C++-Compiler

   Quell-Datei ==> o.-Datei (Linux) // obj.-Datei (Windows)

   COFF (Common Object File Format) is a file format
   primarily used for object code, executables,
   and shared libraries,
   especially in Unix-like systems and Windows.

== Linker:

   o.-Datei(en) ===> .exe (Windows) // Linux: Datei OHNE Endung (Maschinencode).

   Nebenbei: Sucht main, um den Einsprungpunkt beschreiben zu können.

== Loader (Betriebssystems):

   Maschinencode-Datei (zB. .exe-File): ==> Ausführung.


==========================================

Wozu gibt es eine IDE: Integrated Development Environment:

  Die versteckt diese Schritte vor dem Benutzer.

==========================================

Was ist eine Klasse und ein Objekt?

Klasse:  Auto

   == Beschreibung:

      -- Daten (statischen Charakter)
         >>> Farbe, PS
         >>> aktuelle Position

      -- Funktionen (Methoden): dynamischen Charakter
           ein oder mehrere Daten der Klasse können sich ändern.

         >>> fahren (aktuelle Position ändert sich)
         >>> umspritzen (Farbe ändert sich)
         >>> anzahlKM: Liefert die Anzahl der gef. Kilometer zurück

Objekt:  meinAudi

   Ist ein konkreter Datensatz zu der Klasse.

   Ist eine Ausprägung der Klasse 

Objekt == Instanz.

==========================================

Umsetzung von Klasse und Objekt in C++:

2 / 3 Dateien

Uhrzeit:

int hours;
int minutes;
int seconds;

int hours1;
int minutes1;
int seconds1;

No !!!!

a) Beschreibung der Klasse: 

   Beschreibungsdatei:  Header-Datei (.h)

b) Implementierung der Methoden der Klasse: 

   Implementierungsdatei: .cpp

c) Anwendung

===================================

Eine Säule der OO: 

Robustheit // Korrektheit der Daten eines Objekts:

Beispiel:

C/C++: globale Variabe:

int n;  // global

Von überall kann JEDER Wert in n geschrieben werden !!!

OO: 

Daten kann man INNERHALB eines Objekts kapseln // verstecken:

Die Daten eines Objekts sind von AUSSEN nicht erreichbar.

Folge: Wenn die Methoden / die Klasse selbst korrekt implementiert ist,
dann sind die Daten eines Objekts immer korrekt.

Zugriffsschutz:
---------------

a) public // private:

b) Um Variablen ändern / schreiben zu können:

   Spezielle Methoden: getter / setter



Frage: protected:  Gibt es (nur) im Umfeld der Vererbung.

=========================================================

    Time now;
    now.setHours(10);
   // now.setMinutes(32);
    now.setSeconds(30);

Ginge / Geht : Ist schlecht.

Was ist schlecht.

Kann einen setter vergessen ?!?!
Dann ist das Objekt unvollständig initialisiert!!!

===> Abhilfe:

OO: Ein Objekt hat zu JEDEM ZEITPUNKT gültige Werte !!!

a) setter.

b) Konstruktoren: Spezielle Methoden, mit denen die Instanzvariablen
   eines Objekts vorbelegt werden.

   Zum Zeitpunkt des Anlegens eines Objekts aufgerufen.
  
  Vermeiden:

    Time now;
    now.setHours(10);
   // now.setMinutes(32);
    now.setSeconds(30);

Besser:

    Time now(10, 32, 30);  

    2 Dinge:

    i) Ein Objekt mit dem Namen now wird vereinbart.
    ii) Es wird ein Konstruktor aufgerufen.


a) Feature: Constructor Chaining - ab C++ 11

b) Feature: Member Initializer List - Classic C++

Wozu: Zwingend notwendig bei Vererbung.

Kann aber auch OHNE Vererbung eingesetzt werden.

c) Feature: Konvertierungskonstruktor:

   Was ist das: Gewöhnlicher Konstruktor.

   Aber: Mit nur einem Parameter.

Beispiel:

    Time(int seconds);    //zB 10.000 Sekunden ==> Stunden, Minuten und Sekunden

Worin besteht hier  die "Konvertierung":

int ===> Time

=========================================================

Magischen Keys:

F9:  Haltepunkt

F5:  Go bis zum nächsten Haltepunkt

F11:  Gehe in ein Unterprogramm REIN

F12:  Springe über das Unterprogramm hinweg.

Debugger // Debug-Mode:

Nicht initialisierte Variablen werden (am Stack) 
mit 0xCCCC vorbelegt.

=====================================================

Datentyp Zeiger

Datentyp Referenz

Einordnung:
-----------

C:     Hier gibt es den Datentyp Zeiger (Pointer)
       // keine Referenz

C++:   Hier gibt es den Datentyp Referenz

       ... und den Datentyp Zeiger (Pointer), weil C in C++ enthalten ist.


Frage: Sollte ich dann in C++ nur Referenz .. oder Zeiger ... oder beides verwenden:

       Antwort: BEIDES.

       Wann ist welches Sprachmittel einzusetzen ??? 

       A) Zeiger: Im Umfeld der dynamischen Speicherverwaltung (new / delete).

       B) Referenz: Um bei vorhandenen Objekten durch einen Alias eine
          Kopie zu vermeiden.

=====================================================================

Erfolgt // Mächtigkeit // Verbreitung von C:

Datentyp Pointer ==> Adresse.

Abstand Assembler // C/C++ ist gering : PERFORMANZ.

=====================================================================

Datentyp Pointer:

2 zentrale Operatoren:

&:   Adresse von
*:   Indirekter Zugriff (mit Hilfe der Adresse) // lesend oder schreibend

// ===================================================================

Feature:  Adress-Arithmetik

    pi++;   // die Adresse inkrementieren.

Frage / Beispiel:

Vorher:  Adresse 0x1024  (implizit, weil Adresse auf int: 0x1024, 0x1025, 0x1026, 0x1027)
Nachher: Adresse 0x1028

Wozu / und Wann:

Ja, dieses macht Sinn: 

Bei dynamischen Speicherverwaltung: Wenn mehrere, zB int-Variablen, allokiert werden.

==============================================================================

C:  Datentyp Zeiger: Fundament der Sprache.

Hmmm, kann Fehler verursachen .. ist nicht ganz einfach im Handling.

Design von C++:

Geht das mit dem Zeiger einfacher / besser lesbar ???

Yes: Alternative Konzept: Referenz.

(( zB für die Parameterübergabe konzipert ))

Feature / Eigenschaft erzwungen / berücksichtigt:

   Keine Null-Referenzen.

Wie kann man eine C++-Referenz definieren / beschreiben:

____________________________________________________________
Eine Referenz ist ein zweiter Name (Bezeichner / Identifier)
für eine vorhandene Variable / Objekt.
____________________________________________________________
Oder:
Eine Referenz ist ein Alias-Name (Bezeichner / Identifier)
für eine vorhandene Variable / Objekt.
------------------------------------------------------------

Etwas technischer:

Eine Referenz-Variable enthält die Adresse 
einer vorhandenen Variable / eines vorhandenen Objekts.


===============================================================

Referenzen und const:

a) Referenzen sind ein ALIAS für ein Original.

b) Man kann das Original schützen:

   Mit const. ==> nur lesender Zugriff möglich.

Frage:
Ist das mit dem const den Aufwand wert ????

public:
    // getter / setter
    int  getHours() const;            // lesender Zugriff
    void setHours(int hours);         // schreibender Zugriff
    int  getMinutes() const;          // lesender Zugriff
    void setMinutes(int minutes);     // schreibender Zugriff
    int  getSeconds() const;          // lesender Zugriff
    void setSeconds(int seconds);     // schreibender Zugriff

    bool compare(const Time& other) const;

Jaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa

Why ?????????????????????????

Wenn eine Methode const deklariert ist ,
dann hat der Optimizer mehr Möglichkeiten, "performanten" Maschinencode zu erstellen.

Performanz  =======> Go for "const"

Einmal "const" -- immer "const"

==============================================================

Übung:

Klasse und Objekt: check

Konstruktoren:     

  BankAccout:  Standard-Konstruktor:  Null Euros

  BankAccout:  Mit 50 Euros Startguthaben.  // ein zweiter Konstruktor //chaining


Zugriffsklassen: check

getter- und setter-Methoden: check

Kontostand:  Getter:   getBalance


Methoden:

BankAccount myAccount(50);
myAccount.deposit(50);
myAccount.withdraw(25);
myAccount.print();

Logo : Wenn "nix" auf dem Konto ist (withdraw),
dann geht das nicht.

void deposit (int euros);
oder
void deposit (double euros);  // ganze Euros und Cents  // 123.45


bool withdraw (double amount);   // ganze Euros und Cents  // 123.45


bool withdraw (int euros);

bool withdraw (double amount);   // ganze Euros und Cents  // 123.45


equals: Sind zwei Konten gleich -- bzgl. Kontostand !!!!!!!!!!!!

VORSICHT: Das bezieht sich auf den Kontostand !!!!!!!!!!!!


Problem: Jedes Konto sollte eine eindeutige Kontonummer haben.

Einfache Lösung:

Globale Variable:

int nextAccountNumber = 10000;

Wünschenswert:

===========================================================================

Static:

Was ist eine static-Variable in einer Klasse:

static tritt in MEHREREN Varianten in Erscheinung:

A) Vor Funktionen in einer Datei.

Datei A: Diese implementiert eine Funktion.

Datei B: Diese möchte die implementiert Funktion von Datei A verwenden.

Geht - mit einer Vorwärts- / extern-Deklaration.

B) Für globale Variablen -- die aber nur in EINER Funktion
                           sichtbar sind.

C) Für globale Variablen -- die aber nur in Klassen
                           sichtbar sind. Hängt von public / private ab.



===============================================================

Überladen von Operatoren
------------------------

Wie geht das ???

Wie Methoden:

   == Man schreibt eine entsprechende Methode: 

   == Welchen Namen hat diese Methode: 'operator =='



Beobachtung:

0x CCCCCCC ==> Stack: nicht initialisiert

0x DDDDDDD ==> Heap: nicht mehr verfügbar, weil freigegeben

0x CDCDCDC ==> Heap: nicht initialisiert.

===========================================================

Beobachtung:

new / delete:

new: "Wird aufgerufen" :)

delete: Hmmm, das ist das eigentliche Problem: Wann, wo, wer ???????????????

===========================================================

new / delete:

Gibt es in ZWEI Varianten:

a) Für einzelne Werte
b) Für ein Feld von Werten.

Array: []

===========================================================

Die Adresse zeigt auf ein Feld von int-Variablen

Frage:  Adresse 160  plus 1  ==> 164

Es gibt bei Zeiger ZWEI SChreibweisen:
  
  ip[i] = i;
  
  IST IDENTISCH ZU
  
  *(ip + i)

Konzept von Zeigern / Adressen in C

Mit Maschinencode:

        *(ip + i) = i;
00007FF6CB0048CF  movsxd      rax,dword ptr [rbp+24h]  
00007FF6CB0048D3  mov         rcx,qword ptr [ip]  
00007FF6CB0048D7  mov         edx,dword ptr [rbp+24h]  
00007FF6CB0048DA  mov         dword ptr [rcx+rax*4],edx  

        ip[i] = i;
00007FF6CB0048F6  movsxd      rax,dword ptr [rbp+44h]  
00007FF6CB0048FA  mov         rcx,qword ptr [ip]  
00007FF6CB0048FE  mov         edx,dword ptr [rbp+44h]  
00007FF6CB004901  mov         dword ptr [rcx+rax*4],edx  

Auch bei mehr-dim. Feldern sieht die Umsetzung in Maschinencode
identisch aus.

Warum?

== Es gibt keine mehr-dim. Feldern in C/C++

numbers[5][10]; liegt im Speicher KONSEKUTIV:

Ironische Bemerkung:
--------------------

int numbers[10]; 

Ironische Bemerkung: "Es gibt keine Felder in C/C++"

==> Dennis Ritchie:

Ist numbers eine Anfangsadresse: Die Adresse des ersten Elements:

    for (int i = 0; i < 10; ++i) {
        *(numbers + i) = i;
    }

Zweite Idee: Vereinfachung der Schreibweise:

    for (int i = 0; i < 10; ++i) {
        numbers[i] = i;
    }

Bei Objekten:

        (*(tp + i)).setHours(i);
00007FF75B6A9F45  movsxd      rax,dword ptr [rbp+24h]  
00007FF75B6A9F49  imul        rax,rax,0Ch    // 0Ch = 12 
00007FF75B6A9F4D  mov         rcx,qword ptr [tp]  
00007FF75B6A9F51  add         rcx,rax  
00007FF75B6A9F54  mov         rax,rcx  
00007FF75B6A9F57  mov         edx,dword ptr [rbp+24h]  
00007FF75B6A9F5A  mov         rcx,rax  
00007FF75B6A9F5D  call        Time::setHours (07FF75B6A1352h)  

Maschinencode:

Es schadet nicht, da mal hinzusehen :)

=======================================================

Zeichen und Zeichenketten

==> STL  // Klasse std::string

=============================================

size_t

versus

int:

Hmmm, int ist vom ersten Tag der Typ für ganze Zahlen.

Puristen: Es gibt immer wieder Situationen, wo es keine negativen Zahlen gibt:

size_t ist der Typ für ganze, POSITIVE Zahlen.

==============================================

Wie sieht in Objekt std::string s ("12345") intern aus ????

==============================================

Frage:

Wie bekomme ich aus einer Funktion / Methode
ein oder mehrere Ergebnisse zurück ????

i) Ein: Über den Rückgabewert.

ii) ODER:

    bool success = obj.tueWas (obj2, result);

    tueWas (const X& first, X& second);

    Der zweite Parameter ist für das Ergebis gedacht.

iii) Mehrere:

   Die Funktion liefert eine Struktur / ein Objekt zurück.

   ==> Leicht strukturierteren Geschmack

iv) Mehrere:

   Die Funktion hat mehrere NICHT-const Parameter,
   in die das Ergebnis reingeschrieben werden.



=============================================================

Aufgabe

https://github.com/pelocpp/cpp_introduction/blob/master/Cpp_Introduction/Exercises/Exercises_Strings.md

Hinweis:

std::string dateToWord(const std::string& date);

Das ist die Vorgabe.

ALTERNATIVE:

void dateToWord2(const std::string& date, std::string& result);

Es klappt etwas nicht:

result = "";  // Ginge

ODER:

bool dateToWord2(const std::string& date, std::string& result);

true / false:

HINWEIS:

bool dateToWord (std::string date, std::string& result);

GINGE: Ist nicht performant, weil im ersten
Parameter eine überflüssige Kopie an 'dateToWord' übergeben wird.

===============================================================

Parameterübergabemechanismus Call-by-Value.

==> Funktion arbeitet mit einer Kopie:

    Das Original wird geschützt.


===============================================================

Recap:

Klassen und Objeke

Klasse Time
Klasse BankAccount

===> Eigenschaft: Es gab keine dynamischen Daten in den Objekten dieser Klassen.

Weiteres Beispiel:

Klasse BigData:

Ziel:

Kann ein Feld von Daten einer beliebigen Länge 
verwalten / aufnehmen .. und Operationen darauf bereitstellen.

Dynamische Daten UND OO

Wertzuweisung von Objekten:  GEHT.

Wie:  Es werden alle Werte 1:1 umkopiert.

Maschinenenraum von C++:
------------------------

A) Destruktor

B) Wertzuweisung

Im Falle des Vorhandenseins von dyn. Daten
ist der Wertzuweisungs-Operator EXPLIZIT zu implementieren.

C) Kopie eines Objekts:

Im Falle des Vorhandenseins von dyn. Daten
ist zum Erstellen einer Kopie eines Objekts
der sog. Kopier-Destruktor EXPLIZIT zu implementieren.


Wann müssen wir die "Rule-of_Three" anwenden / umsetzen / realisieren ???

Wenn in den Objekten Variablen / Zeigervariablen vorhanden sind,
die mittels new / delete zusammen arbeiten.

===============================================================

Modern C++:   Smart Pointer Klassen

std::unique_ptr
std::shared_ptr

Die arbeiten "anders"

===============================================================

Regel in der Reihenfolge der catch-Blocke:

Vom Speziellen zum Allgemeinen:

EXAKT: Vererbung // Basisklasse // Abgl. Klasse 

===============================================================

Vererbung:
----------

Konzept der OO

// Funktionalen Programmierung

Wann setzen wir Vererbung ein ?????????????

Hintergrund:   // Anschaulich

Fragen:

== Klasse Rechteck // Rectangle

== Klasse FarbigesRechteck // ColoredRectangle

Satz: FarbigesRechteck ist eine spezielle Version eines Rechtecks.

==>  "Ein FarbigesRechteck ist ein Rechteck"

Beziehungen // Design von Klassen und Software // Relationship:

Beziehung:   "ist-ein" // is-a 

 "ist-ein" Beziehung: Vorausetzung wenn ich Vererbung einsetzen möchte.

 == Klasse Linie // class Line

 == Klasse Punkt // class Point

 Satz: Ein Punkt ist keine Linie

       Eine Linie ist ein Punkt ??? No

       Eine Linie besteht aus vielen Punkten

       Eine Linie besteht aus zwei Punkten (Anfang / Ende)

       Eine Linie hat zwei verschiedene Punkte (Anfang / Ende)

"hat-ein" Beziehung // Plural auch möglich (Nicht: unendlich)

"has-a" Relationship:

a) Hier kann VERERBUNG NICHT angewendet werden.

b) 

class Line
{
private:
    Point m_begin;
    Point m_end;

    Color m_color;  // ???

    int   m_index; // geht datentechnisch // lokale Variable einer Methode // NEIN
}

"hat-ein" Beziehung  ===> Instanzvariablen (Member) // Eigenschaften einer Klasse 

100.000 Linien: Speicherplatz

///////////////////////////////////////////////////////////////

Habe eine Klasse Rechteck.

Benötige eine Klasse FarbigesRechteck.

Alles "öffentliche" (public) wird an die Kindklasse vererbt.

AUSNAHME: Keine Konstruktoren !!!

Wording:
=======

Basisklasse (base class) / abgeleitete Klasse (derived class)

Parent Class / Child Class (Kindklasse)

// ==========================================================

Anschauliche Betrachtung
========================

Was bedeutet Vererbung?

"Ich erbe alles von der Vaterklasse (Oma)" :)

Nope - es gibt hier DREI Optionen:

A) Es wird eine Methode "geerbt".  Passt (gibt nichts zu erweitern) // Häufig

B) Eine Methode wird ersetzt / ausgetauscht / ausgewechselt. ??!?!?!?!

   Hmmmm: Steht im Widerspruch zur is-a Beziehung.

   Vorsicht: "Smell"  // Geruch // "Code smells" // ist das wirklich so gewollt.

C) Eine Methode wird erweitert / verfeinert. Passt // Häufig

===========================================================

Grundlagen der Vererbung.

Besondere Features der Vererbung.

A) Virtuelle Methodenaufrufmechanismus.
-----------------------------------

B) Polymorphismus
-----------------------------------

Aufruf einer Methode an einer Basisklasse,
der zu einem tatsächlichen Aufruf einer Methode einer Kindklasse führt.

Exakter:
Aufruf einer Methode (an einem Zeiger) auf eine Basisklasse,
der zu einem tatsächlichen Aufruf einer Methode einer Kindklasse führt.


figures[i]->draw();

Wie nennt man das: 
i) Mehrere Methoden kommen in Frage: Poly
ii) Gestalt: Morphus



// Objekte dynamisch vorliegen // Mit Adressen arbeiten

Unterscheidung:
--------------

Compile-Time // Übersetzungszeit

Runtime      // Laufzeit

Will ich eine Unterscheidung zur Laufzeit: virtual

Einmal virtual // immer virtual

Tipp: In den Kindklassen: Keyword override verwenden.  // C++ 11 

===========================================

final:

===========================================

2 Begriffe:

== Abstrakte Klasse

== Interface // Schnittstelle

===========================================

Was ist ein "Interface" // "Schnittstelle" im Sinne der OO ???
--------------------------------------------------------------

Ist auch ein Entwurfsmittel.

a) Ein Vertrag // Kontrakt.

   Dieser beschreibt ein oder mehrere Methoden (Name, Parameter der Methode),
   sie haben KEINE Implementierung.

b) Klassen können eine Vertrag erfüllen:

   Es sind dann alle Methoden des Vertrags (der Schnittstelle) zu implementieren.


Hinweis: Hier wird nichts "vererbt":

Man kann es so sagen: Es werden die Anforderungen eines Vertrags vererbt.

Sprachliches Konstrukt: C#, Java, ...: Keyword interface

Nicht direkt in C++: Kein keyword 'interface'

Umsetzung in C++:

struct IRectangle
{
    virtual void draw() = 0;
};

Was bedeutet "= 0";  

Anschauliche Betrachtung ????
Methoden eine Klasse haben eine Adresse.
Methoden einer Schnittstelle haben KEINE Adresse.

===========================================

Was ist eine abstrakte Klasse im Sinne der OO ???
-------------------------------------------------

i) Eine unvollständige Klasse 

ii) Eine unvollständige Klasse hat in der Regel:

a) Instanzvariablen // solche, die für ALLE Kindklassen relevant sind !!!

b) Implementiert Methoden // solche, die für ALLE Kindklassen relevant sind !!!

   (( Kann virtual oder nicht-virtual sein ))

c) Besitzt ein oder mehrere Methoden OHNE Realisierung:
 
   Diese MÜSSEN von ALLEN Kindklassen realisiert werden ....
   UND es ist nicht möglich, eine wie auch immer geartete Realisierung
   in der aktuellen Klasse vorzunehmen.

   ==> Hat Charakter einer Schnittstelle / Interface

d) Von einer abstrakten Klasse kann man KEIN Objekt erzeugen.

e) Aber: Eine abstrakte Klasse eignet sich hervorragend als Basisklasse,
   weil sie Teile der Funktionalität (Daten / Methoden) bereitstellt.

====================================================================

Unterschied:
Schnittstelle versus abstrakte Basisklasse (unvollständige Hilfsklasse)

====================================================================

Übung:

https://github.com/pelocpp/cpp_introduction/blob/master/Cpp_Introduction/Exercises/Exercises_MoreBankAccounts.md

