C++ Grundlagen

Peter Loos

peter.loos@gmx.de

https://github.com/pelocpp

Classic C++:

Einführung:

https://github.com/pelocpp/cpp_introduction


Modern C++:

https://github.com/pelocpp/cpp_modern

================

12.30: 

Kaffeepause

17.00 

Übungen:   Nachmittagsstunden ....

================

ToDo:
=====


B) std::copy_if  // Filtern in der STL


================================================================

================


Background:

C/C++ ... Java ... C# ...JavaScript ... 

Python wenig (zeitlich)

Back to the Roots: C/C++ (Nachfrage)

================

Erwartungen

== C++ kennen und anwenden 
== C++ Programme schreiben können
== C++ vertiefen
== C++ Programme lesen können
== .......................

== Tiefer in das OOP
== Architektur
== Embedded-Bereich
== Speicherverwaltung

== C++ 11 / 17 and beyond: Da kann ich gerne am Ende
               einen 2-4 stündigen Überblick geben.


== Classic C++ :  Vom ersten Tag an ... BIS C++ 11

   Fundament in C++

== Modern C++:    C++ 11 bis heute (C++ 23 / 26)

================

Online-Seminar:

a) Tool: Visual Studio

b) Unterlagen:  Github:  

https://github.com/pelocpp

Classic C++:

https://github.com/pelocpp/cpp_introduction

================

Hinweis:

C ist in C++ enthalten (99%)

C-Kenntnisse sind vorhanden (for, if, ...)

================

Jederzeit / Zwischendrin: 

Fazit // langsamer // schneller // Passd scho


================

VS Code: 

Installation von Gcc // MinGW (GCC) etc. // Extensions selber machen.


================

Namensraum:  

std::cout

Ich will ein Objekt cout benennen:

================

Übersetzung eines C/C++ Programms:

C++:  Übersetzungseinheit: Eine C++ - Datei (keine Header-Datei)

== Präprozessor (Tool, um #-Direktiven aufzulösen)

== C/C++-Compiler

   Quell-Datei ==> o.-Datei (Linux) // obj.-Datei (Windows)

   COFF (Common Object File Format) is a file format
   primarily used for object code, executables,
   and shared libraries,
   especially in Unix-like systems and Windows.

== Linker:

   o.-Datei(en) ===> .exe (Windows) // Linux: Datei OHNE Endung (Maschinencode).

   Nebenbei: Sucht main, um den Einsprungpunkt beschreiben zu können.

== Loader (Betriebssystems):

   Maschinencode-Datei (zB. .exe-File): ==> Ausführung.


==========================================

Wozu gibt es eine IDE: Integrated Development Environment:

  Die versteckt diese Schritte vor dem Benutzer.

==========================================

Was ist eine Klasse und ein Objekt?

Klasse:  Auto

   == Beschreibung:

      -- Daten (statischen Charakter)
         >>> Farbe, PS
         >>> aktuelle Position

      -- Funktionen (Methoden): dynamischen Charakter
           ein oder mehrere Daten der Klasse können sich ändern.

         >>> fahren (aktuelle Position ändert sich)
         >>> umspritzen (Farbe ändert sich)
         >>> anzahlKM: Liefert die Anzahl der gef. Kilometer zurück

Objekt:  meinAudi

   Ist ein konkreter Datensatz zu der Klasse.

   Ist eine Ausprägung der Klasse 

Objekt == Instanz.

==========================================

Umsetzung von Klasse und Objekt in C++:

2 / 3 Dateien

Uhrzeit:

int hours;
int minutes;
int seconds;

int hours1;
int minutes1;
int seconds1;

No !!!!

a) Beschreibung der Klasse: 

   Beschreibungsdatei:  Header-Datei (.h)

b) Implementierung der Methoden der Klasse: 

   Implementierungsdatei: .cpp

c) Anwendung

===================================

Eine Säule der OO: 

Robustheit // Korrektheit der Daten eines Objekts:

Beispiel:

C/C++: globale Variabe:

int n;  // global

Von überall kann JEDER Wert in n geschrieben werden !!!

OO: 

Daten kann man INNERHALB eines Objekts kapseln // verstecken:

Die Daten eines Objekts sind von AUSSEN nicht erreichbar.

Folge: Wenn die Methoden / die Klasse selbst korrekt implementiert ist,
dann sind die Daten eines Objekts immer korrekt.

Zugriffsschutz:
---------------

a) public // private:

b) Um Variablen ändern / schreiben zu können:

   Spezielle Methoden: getter / setter



Frage: protected:  Gibt es (nur) im Umfeld der Vererbung.

=========================================================

    Time now;
    now.setHours(10);
   // now.setMinutes(32);
    now.setSeconds(30);

Ginge / Geht : Ist schlecht.

Was ist schlecht.

Kann einen setter vergessen ?!?!
Dann ist das Objekt unvollständig initialisiert!!!

===> Abhilfe:

OO: Ein Objekt hat zu JEDEM ZEITPUNKT gültige Werte !!!

a) setter.

b) Konstruktoren: Spezielle Methoden, mit denen die Instanzvariablen
   eines Objekts vorbelegt werden.

   Zum Zeitpunkt des Anlegens eines Objekts aufgerufen.
  
  Vermeiden:

    Time now;
    now.setHours(10);
   // now.setMinutes(32);
    now.setSeconds(30);

Besser:

    Time now(10, 32, 30);  

    2 Dinge:

    i) Ein Objekt mit dem Namen now wird vereinbart.
    ii) Es wird ein Konstruktor aufgerufen.


a) Feature: Constructor Chaining - ab C++ 11

b) Feature: Member Initializer List - Classic C++

Wozu: Zwingend notwendig bei Vererbung.

Kann aber auch OHNE Vererbung eingesetzt werden.

c) Feature: Konvertierungskonstruktor:

   Was ist das: Gewöhnlicher Konstruktor.

   Aber: Mit nur einem Parameter.

Beispiel:

    Time(int seconds);    //zB 10.000 Sekunden ==> Stunden, Minuten und Sekunden

Worin besteht hier  die "Konvertierung":

int ===> Time

=========================================================

Magischen Keys:

F9:  Haltepunkt

F5:  Go bis zum nächsten Haltepunkt

F11:  Gehe in ein Unterprogramm REIN

F12:  Springe über das Unterprogramm hinweg.

Debugger // Debug-Mode:

Nicht initialisierte Variablen werden (am Stack) 
mit 0xCCCC vorbelegt.

=====================================================

Datentyp Zeiger

Datentyp Referenz

Einordnung:
-----------

C:     Hier gibt es den Datentyp Zeiger (Pointer)
       // keine Referenz

C++:   Hier gibt es den Datentyp Referenz

       ... und den Datentyp Zeiger (Pointer), weil C in C++ enthalten ist.


Frage: Sollte ich dann in C++ nur Referenz .. oder Zeiger ... oder beides verwenden:

       Antwort: BEIDES.

       Wann ist welches Sprachmittel einzusetzen ??? 

       A) Zeiger: Im Umfeld der dynamischen Speicherverwaltung (new / delete).

       B) Referenz: Um bei vorhandenen Objekten durch einen Alias eine
          Kopie zu vermeiden.

=====================================================================

Erfolgt // Mächtigkeit // Verbreitung von C:

Datentyp Pointer ==> Adresse.

Abstand Assembler // C/C++ ist gering : PERFORMANZ.

=====================================================================

Datentyp Pointer:

2 zentrale Operatoren:

&:   Adresse von
*:   Indirekter Zugriff (mit Hilfe der Adresse) // lesend oder schreibend

// ===================================================================

Feature:  Adress-Arithmetik

    pi++;   // die Adresse inkrementieren.

Frage / Beispiel:

Vorher:  Adresse 0x1024  (implizit, weil Adresse auf int: 0x1024, 0x1025, 0x1026, 0x1027)
Nachher: Adresse 0x1028

Wozu / und Wann:

Ja, dieses macht Sinn: 

Bei dynamischen Speicherverwaltung: Wenn mehrere, zB int-Variablen, allokiert werden.

==============================================================================

C:  Datentyp Zeiger: Fundament der Sprache.

Hmmm, kann Fehler verursachen .. ist nicht ganz einfach im Handling.

Design von C++:

Geht das mit dem Zeiger einfacher / besser lesbar ???

Yes: Alternative Konzept: Referenz.

(( zB für die Parameterübergabe konzipert ))

Feature / Eigenschaft erzwungen / berücksichtigt:

   Keine Null-Referenzen.

Wie kann man eine C++-Referenz definieren / beschreiben:

____________________________________________________________
Eine Referenz ist ein zweiter Name (Bezeichner / Identifier)
für eine vorhandene Variable / Objekt.
____________________________________________________________
Oder:
Eine Referenz ist ein Alias-Name (Bezeichner / Identifier)
für eine vorhandene Variable / Objekt.
------------------------------------------------------------

Etwas technischer:

Eine Referenz-Variable enthält die Adresse 
einer vorhandenen Variable / eines vorhandenen Objekts.


===============================================================

Referenzen und const:

a) Referenzen sind ein ALIAS für ein Original.

b) Man kann das Original schützen:

   Mit const. ==> nur lesender Zugriff möglich.

Frage:
Ist das mit dem const den Aufwand wert ????

public:
    // getter / setter
    int  getHours() const;            // lesender Zugriff
    void setHours(int hours);         // schreibender Zugriff
    int  getMinutes() const;          // lesender Zugriff
    void setMinutes(int minutes);     // schreibender Zugriff
    int  getSeconds() const;          // lesender Zugriff
    void setSeconds(int seconds);     // schreibender Zugriff

    bool compare(const Time& other) const;

Jaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa

Why ?????????????????????????

Wenn eine Methode const deklariert ist ,
dann hat der Optimizer mehr Möglichkeiten, "performanten" Maschinencode zu erstellen.

Performanz  =======> Go for "const"

Einmal "const" -- immer "const"

==============================================================

Übung:

Klasse und Objekt: check

Konstruktoren:     

  BankAccout:  Standard-Konstruktor:  Null Euros

  BankAccout:  Mit 50 Euros Startguthaben.  // ein zweiter Konstruktor //chaining


Zugriffsklassen: check

getter- und setter-Methoden: check

Kontostand:  Getter:   getBalance


Methoden:

BankAccount myAccount(50);
myAccount.deposit(50);
myAccount.withdraw(25);
myAccount.print();

Logo : Wenn "nix" auf dem Konto ist (withdraw),
dann geht das nicht.

void deposit (int euros);
oder
void deposit (double euros);  // ganze Euros und Cents  // 123.45


bool withdraw (double amount);   // ganze Euros und Cents  // 123.45


bool withdraw (int euros);

bool withdraw (double amount);   // ganze Euros und Cents  // 123.45


equals: Sind zwei Konten gleich -- bzgl. Kontostand !!!!!!!!!!!!

VORSICHT: Das bezieht sich auf den Kontostand !!!!!!!!!!!!


Problem: Jedes Konto sollte eine eindeutige Kontonummer haben.

Einfache Lösung:

Globale Variable:

int nextAccountNumber = 10000;

Wünschenswert:

===========================================================================

Static:

Was ist eine static-Variable in einer Klasse:

static tritt in MEHREREN Varianten in Erscheinung:

A) Vor Funktionen in einer Datei.

Datei A: Diese implementiert eine Funktion.

Datei B: Diese möchte die implementiert Funktion von Datei A verwenden.

Geht - mit einer Vorwärts- / extern-Deklaration.

B) Für globale Variablen -- die aber nur in EINER Funktion
                           sichtbar sind.

C) Für globale Variablen -- die aber nur in Klassen
                           sichtbar sind. Hängt von public / private ab.



===============================================================

Überladen von Operatoren
------------------------

Wie geht das ???

Wie Methoden:

   == Man schreibt eine entsprechende Methode: 

   == Welchen Namen hat diese Methode: 'operator =='



Beobachtung:

0x CCCCCCC ==> Stack: nicht initialisiert

0x DDDDDDD ==> Heap: nicht mehr verfügbar, weil freigegeben

0x CDCDCDC ==> Heap: nicht initialisiert.

===========================================================

Beobachtung:

new / delete:

new: "Wird aufgerufen" :)

delete: Hmmm, das ist das eigentliche Problem: Wann, wo, wer ???????????????

===========================================================

new / delete:

Gibt es in ZWEI Varianten:

a) Für einzelne Werte
b) Für ein Feld von Werten.

Array: []

===========================================================

Die Adresse zeigt auf ein Feld von int-Variablen

Frage:  Adresse 160  plus 1  ==> 164

Es gibt bei Zeiger ZWEI SChreibweisen:
  
  ip[i] = i;
  
  IST IDENTISCH ZU
  
  *(ip + i)

Konzept von Zeigern / Adressen in C

Mit Maschinencode:

        *(ip + i) = i;
00007FF6CB0048CF  movsxd      rax,dword ptr [rbp+24h]  
00007FF6CB0048D3  mov         rcx,qword ptr [ip]  
00007FF6CB0048D7  mov         edx,dword ptr [rbp+24h]  
00007FF6CB0048DA  mov         dword ptr [rcx+rax*4],edx  

        ip[i] = i;
00007FF6CB0048F6  movsxd      rax,dword ptr [rbp+44h]  
00007FF6CB0048FA  mov         rcx,qword ptr [ip]  
00007FF6CB0048FE  mov         edx,dword ptr [rbp+44h]  
00007FF6CB004901  mov         dword ptr [rcx+rax*4],edx  

Auch bei mehr-dim. Feldern sieht die Umsetzung in Maschinencode
identisch aus.

Warum?

== Es gibt keine mehr-dim. Feldern in C/C++

numbers[5][10]; liegt im Speicher KONSEKUTIV:

Ironische Bemerkung:
--------------------

int numbers[10]; 

Ironische Bemerkung: "Es gibt keine Felder in C/C++"

==> Dennis Ritchie:

Ist numbers eine Anfangsadresse: Die Adresse des ersten Elements:

    for (int i = 0; i < 10; ++i) {
        *(numbers + i) = i;
    }

Zweite Idee: Vereinfachung der Schreibweise:

    for (int i = 0; i < 10; ++i) {
        numbers[i] = i;
    }

Bei Objekten:

        (*(tp + i)).setHours(i);
00007FF75B6A9F45  movsxd      rax,dword ptr [rbp+24h]  
00007FF75B6A9F49  imul        rax,rax,0Ch    // 0Ch = 12 
00007FF75B6A9F4D  mov         rcx,qword ptr [tp]  
00007FF75B6A9F51  add         rcx,rax  
00007FF75B6A9F54  mov         rax,rcx  
00007FF75B6A9F57  mov         edx,dword ptr [rbp+24h]  
00007FF75B6A9F5A  mov         rcx,rax  
00007FF75B6A9F5D  call        Time::setHours (07FF75B6A1352h)  

Maschinencode:

Es schadet nicht, da mal hinzusehen :)

=======================================================

Zeichen und Zeichenketten

==> STL  // Klasse std::string

=============================================

size_t

versus

int:

Hmmm, int ist vom ersten Tag der Typ für ganze Zahlen.

Puristen: Es gibt immer wieder Situationen, wo es keine negativen Zahlen gibt:

size_t ist der Typ für ganze, POSITIVE Zahlen.

==============================================

Wie sieht in Objekt std::string s ("12345") intern aus ????

==============================================

Frage:

Wie bekomme ich aus einer Funktion / Methode
ein oder mehrere Ergebnisse zurück ????

i) Ein: Über den Rückgabewert.

ii) ODER:

    bool success = obj.tueWas (obj2, result);

    tueWas (const X& first, X& second);

    Der zweite Parameter ist für das Ergebis gedacht.

iii) Mehrere:

   Die Funktion liefert eine Struktur / ein Objekt zurück.

   ==> Leicht strukturierteren Geschmack

iv) Mehrere:

   Die Funktion hat mehrere NICHT-const Parameter,
   in die das Ergebnis reingeschrieben werden.



=============================================================

Aufgabe

https://github.com/pelocpp/cpp_introduction/blob/master/Cpp_Introduction/Exercises/Exercises_Strings.md

Hinweis:

std::string dateToWord(const std::string& date);

Das ist die Vorgabe.

ALTERNATIVE:

void dateToWord2(const std::string& date, std::string& result);

Es klappt etwas nicht:

result = "";  // Ginge

ODER:

bool dateToWord2(const std::string& date, std::string& result);

true / false:

HINWEIS:

bool dateToWord (std::string date, std::string& result);

GINGE: Ist nicht performant, weil im ersten
Parameter eine überflüssige Kopie an 'dateToWord' übergeben wird.

===============================================================

Parameterübergabemechanismus Call-by-Value.

==> Funktion arbeitet mit einer Kopie:

    Das Original wird geschützt.


===============================================================

Recap:

Klassen und Objeke

Klasse Time
Klasse BankAccount

===> Eigenschaft: Es gab keine dynamischen Daten in den Objekten dieser Klassen.

Weiteres Beispiel:

Klasse BigData:

Ziel:

Kann ein Feld von Daten einer beliebigen Länge 
verwalten / aufnehmen .. und Operationen darauf bereitstellen.

Dynamische Daten UND OO

Wertzuweisung von Objekten:  GEHT.

Wie:  Es werden alle Werte 1:1 umkopiert.

Maschinenenraum von C++:
------------------------

A) Destruktor

B) Wertzuweisung

Im Falle des Vorhandenseins von dyn. Daten
ist der Wertzuweisungs-Operator EXPLIZIT zu implementieren.

C) Kopie eines Objekts:

Im Falle des Vorhandenseins von dyn. Daten
ist zum Erstellen einer Kopie eines Objekts
der sog. Kopier-Destruktor EXPLIZIT zu implementieren.


Wann müssen wir die "Rule-of_Three" anwenden / umsetzen / realisieren ???

Wenn in den Objekten Variablen / Zeigervariablen vorhanden sind,
die mittels new / delete zusammen arbeiten.

===============================================================

Modern C++:   Smart Pointer Klassen

std::unique_ptr
std::shared_ptr

Die arbeiten "anders"

===============================================================

Regel in der Reihenfolge der catch-Blocke:

Vom Speziellen zum Allgemeinen:

EXAKT: Vererbung // Basisklasse // Abgl. Klasse 

===============================================================

Vererbung:
----------

Konzept der OO

// Funktionalen Programmierung

Wann setzen wir Vererbung ein ?????????????

Hintergrund:   // Anschaulich

Fragen:

== Klasse Rechteck // Rectangle

== Klasse FarbigesRechteck // ColoredRectangle

Satz: FarbigesRechteck ist eine spezielle Version eines Rechtecks.

==>  "Ein FarbigesRechteck ist ein Rechteck"

Beziehungen // Design von Klassen und Software // Relationship:

Beziehung:   "ist-ein" // is-a 

 "ist-ein" Beziehung: Vorausetzung wenn ich Vererbung einsetzen möchte.

 == Klasse Linie // class Line

 == Klasse Punkt // class Point

 Satz: Ein Punkt ist keine Linie

       Eine Linie ist ein Punkt ??? No

       Eine Linie besteht aus vielen Punkten

       Eine Linie besteht aus zwei Punkten (Anfang / Ende)

       Eine Linie hat zwei verschiedene Punkte (Anfang / Ende)

"hat-ein" Beziehung // Plural auch möglich (Nicht: unendlich)

"has-a" Relationship:

a) Hier kann VERERBUNG NICHT angewendet werden.

b) 

class Line
{
private:
    Point m_begin;
    Point m_end;

    Color m_color;  // ???

    int   m_index; // geht datentechnisch // lokale Variable einer Methode // NEIN
}

"hat-ein" Beziehung  ===> Instanzvariablen (Member) // Eigenschaften einer Klasse 

100.000 Linien: Speicherplatz

///////////////////////////////////////////////////////////////

Habe eine Klasse Rechteck.

Benötige eine Klasse FarbigesRechteck.

Alles "öffentliche" (public) wird an die Kindklasse vererbt.

AUSNAHME: Keine Konstruktoren !!!

Wording:
=======

Basisklasse (base class) / abgeleitete Klasse (derived class)

Parent Class / Child Class (Kindklasse)

// ==========================================================

Anschauliche Betrachtung
========================

Was bedeutet Vererbung?

"Ich erbe alles von der Vaterklasse (Oma)" :)

Nope - es gibt hier DREI Optionen:

A) Es wird eine Methode "geerbt".  Passt (gibt nichts zu erweitern) // Häufig

B) Eine Methode wird ersetzt / ausgetauscht / ausgewechselt. ??!?!?!?!

   Hmmmm: Steht im Widerspruch zur is-a Beziehung.

   Vorsicht: "Smell"  // Geruch // "Code smells" // ist das wirklich so gewollt.

C) Eine Methode wird erweitert / verfeinert. Passt // Häufig

===========================================================

Grundlagen der Vererbung.

Besondere Features der Vererbung.

A) Virtuelle Methodenaufrufmechanismus.
-----------------------------------

B) Polymorphismus
-----------------------------------

Aufruf einer Methode an einer Basisklasse,
der zu einem tatsächlichen Aufruf einer Methode einer Kindklasse führt.

Exakter:
Aufruf einer Methode (an einem Zeiger) auf eine Basisklasse,
der zu einem tatsächlichen Aufruf einer Methode einer Kindklasse führt.


figures[i]->draw();

Wie nennt man das: 
i) Mehrere Methoden kommen in Frage: Poly
ii) Gestalt: Morphus



// Objekte dynamisch vorliegen // Mit Adressen arbeiten

Unterscheidung:
--------------

Compile-Time // Übersetzungszeit

Runtime      // Laufzeit

Will ich eine Unterscheidung zur Laufzeit: virtual

Einmal virtual // immer virtual

Tipp: In den Kindklassen: Keyword override verwenden.  // C++ 11 

===========================================

final:

===========================================

2 Begriffe:

== Abstrakte Klasse

== Interface // Schnittstelle

===========================================

Was ist ein "Interface" // "Schnittstelle" im Sinne der OO ???
--------------------------------------------------------------

Ist auch ein Entwurfsmittel.

a) Ein Vertrag // Kontrakt.

   Dieser beschreibt ein oder mehrere Methoden (Name, Parameter der Methode),
   sie haben KEINE Implementierung.

b) Klassen können eine Vertrag erfüllen:

   Es sind dann alle Methoden des Vertrags (der Schnittstelle) zu implementieren.


Hinweis: Hier wird nichts "vererbt":

Man kann es so sagen: Es werden die Anforderungen eines Vertrags vererbt.

Sprachliches Konstrukt: C#, Java, ...: Keyword interface

Nicht direkt in C++: Kein keyword 'interface'

Umsetzung in C++:

struct IRectangle
{
    virtual void draw() = 0;
};

Was bedeutet "= 0";  

Anschauliche Betrachtung ????
Methoden eine Klasse haben eine Adresse.
Methoden einer Schnittstelle haben KEINE Adresse.

===========================================

Was ist eine abstrakte Klasse im Sinne der OO ???
-------------------------------------------------

i) Eine unvollständige Klasse 

ii) Eine unvollständige Klasse hat in der Regel:

a) Instanzvariablen // solche, die für ALLE Kindklassen relevant sind !!!

b) Implementiert Methoden // solche, die für ALLE Kindklassen relevant sind !!!

   (( Kann virtual oder nicht-virtual sein ))

c) Besitzt ein oder mehrere Methoden OHNE Realisierung:
 
   Diese MÜSSEN von ALLEN Kindklassen realisiert werden ....
   UND es ist nicht möglich, eine wie auch immer geartete Realisierung
   in der aktuellen Klasse vorzunehmen.

   ==> Hat Charakter einer Schnittstelle / Interface

d) Von einer abstrakten Klasse kann man KEIN Objekt erzeugen.

e) Aber: Eine abstrakte Klasse eignet sich hervorragend als Basisklasse,
   weil sie Teile der Funktionalität (Daten / Methoden) bereitstellt.

====================================================================

Unterschied:
Schnittstelle versus abstrakte Basisklasse (unvollständige Hilfsklasse)

====================================================================

Übung:

https://github.com/pelocpp/cpp_introduction/blob/master/Cpp_Introduction/Exercises/Exercises_MoreBankAccounts.md

A)

// Single-Responsibility
// eine Schnittstelle, die die Betrachtung eines Bankkontos beschreibt.
struct IAccount
{
  // ...
};

B)

Klasse Account – Teilweise Realisierung der Methoden der Schnittstelle IAccount

C)

2 konkrete Klassen:

= Giro-Konto:  // CurrentAccount
  Hat einen Überziehungslimit // Kreditrahmen.

  Man kann ins Negative bis zu einem Limit (m_limit) abheben.

= Studentenkonto // Schülerkonto:

  Keine Überziehung möglich. // Bis auf 0 kann abgehoben werden.

  ===> Vererbung // virtual // interface // Abstrakte Basisklasse.

  Bitte: Keine Methode hat mehr als 3 Zeilen  ... keep it simple.

=======================================================================

STL:  Bibliothek

C++:  Bjarne Stroustrup

      "C with Classes"


Generischen Programmierung:  (( Templates ))

      Alexander Stepanov

Stroustrup & Stepanov:  ===> Bibliothek für C++

==> STL:  Standard TEMPLATE Library

=======================================================================

Bild:

https://github.com/pelocpp/cpp_modern/blob/master/GeneralSnippets/TemplateClassBasics/TemplatesClassBasics.md

=======================================================================

STL:

== Container
== Iterators
== Algorithmus

"Speziell"

==> Generischen Charakters
==> Templates
==> Konzepte, die es so nur in der STL gibt (Bereichs)

==> Warum verwenden wir sie:  Performanz.

Einstieg:  

Felder // Arrays:  => variablen Länge: std::vector

Zu Beginn: 0

push_back: Ans Ende anfügt.


9, 13, 19, 28, 42

neuerWert = alterWert * 1.5;

80 * 1.5 = 120;

========================================================

Die STL hat viele Design-Vorgaben / Entscheidungen:

== Man soll einen Container "nahtlos" austauschen können.

Hinweis:

Der Index-operator "numbers[i]" ist nur bei Containern vorhanden // möglich,
deren Daten im Speicher dicht aneinander liegen // konsekutiv.

Also wie in einem C-Style Array.

Dies ist zB bei std::list NICHT der Fall.

Abhilfe:

Ein anderes Konzept für den Zugriff auf einzelne Elemente.

Iteratoren-Konzept:
------------------

Was ist ein Iterator:

Eine Position in einem Container.

Was kann man mit einer Position machen?

3 Operationen:   // next, current, getValue

operator* : Wert hinter der Position   // wie dereferenzieren // indirekter Zugriff:

    Achtung: Position muss GÜLTIG sein.

operator++:  Gehe zur nächsten Position

operator==
operator!=:  Vergleich zweier Positionen

Wie komme ist an eine Position an einem Container ???

Container:  

begin():  Position des ersten Elements
end():    Position des letzten Elements // Exakt: Die Position NACH dem Ende // Nirwana

Hinweis:

using ist ähnlich zu typedef


// ================================================================


Teuflische Folge:

Startwert: Vorgegeben

int start = 7;

Nächster Wert:

a) Wenn aktueller Wert gerade:  wert => wert / 2;

b) Wenn aktueller Wert ungerade: wert =>  3 * wert + 1;

Beispiel:

7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1 // , 4, 2, 1

1: Abbruch // Ende.

Beweis:

Warum ist für JEDEN Startwert diese Folge ENDLICH.

In einem STL-Container sind die Werte abzulegen.

Danach sind die Resultate (Wert) des Containers auszugeben.


Sinn und Zweck:

STL - Container

STL - Iteratoren

STL - Algorithmen

Zum Begriff: 

Unter dem Wort  "STL Algorithmen" versteht man eine Reihe von Funktionen,
die auf Container arbeiten ... und zunächst einfachere Tätigkeiten vollziehen:

== Container durchlaufen // traversieren
== füllen
== suchen
== Kopieren
== Daten eines Containers umwandeln ...

    std::for_each(
        numbers.begin(),
        numbers.end(),
        XXX
    );

Der dritte Parameter: 

A) Einfachste Umsetzung: Eine C-Funktion

B) Ein aufrufbaren Objekts

C) Lamda-Funktion


Hinweis:

Leider:

Die Fehlermeldungen (STL / generischen Programmierung) sind häufig REAGIEREND.

================================================

std::for_each:

a) Lesender Zugriff auf einen Wert: copy-by-value

b) Schreibenden Zugriffs: copy-by-reference

=================================================

Frage:

void fun(const Type &a);

The signature does not need to have const &.

"Besser mit Referenz": Why ???

Antwort:

i)   Elem. Datentyp (int, double, float, ...)

     Go for call-by-value: Ist schneller

     (( Logo: Wenn gelesen wird // Schreiben einer Kopie macht keinen Sinn ))

ii)  Objekte (Klasse / Struktur)

     Bei "größeren" Variablen / Objekten tut das Kopieren weh (Zeit / Performanz):

     Hier call-by-Reference:  


Vergleich)

    // Call by Value: void print(int value)
    int m = value;
00007FF705B8393F  mov         eax,dword ptr [value]  
00007FF705B83945  mov         dword ptr [m],eax  



    // Call by Reference: void print(int& value)
    int m = value;
00007FF78FF73FD0  mov         rax,qword ptr [value]  // rax: Adresse-Register
00007FF78FF73FD7  mov         eax,dword ptr [rax]    // indirekte Lesen : eax ist der Akku / Wert
00007FF78FF73FD9  mov         dword ptr [m],eax  


=======================================================================

Suchen nach einem Wert:   std::find

Hinweis:

warning C4834: discarding return value of function with [[nodiscard]] attribute

discarding: ignorieren, wegschmeißen

=======================================================================

Programmieren mit der STL:
--------------------------  

Eigene Stilistik:

Programming with Building Blocks

Programmieren in Blöcken.

=======================================================================

Suchen nach einer Bedingung:   std::find_if

"unary predicate"

Hierzu benötigt man eine Funktion, die einen Parameter hat (Wert aus dem Container),
überprüft die Bedingung und liefert true/false zurück.

=======================================================================

Frage:  Filtern  ..

A) std::ranges // Neue Bibliothek // C++ 17 ... Filter als sprachliches Mittel enthalten.

B) std::copy_if  // Filtern in der STL

=======================================================================

STL und Performanz:   // Embedded

Ist es wert, aus Gründen der Performanz die STL einzusetze ???????????

Vergleich.


Wieso sind die STL-Algorithmen so schnell:

==> std::memset

Memory Set

Es gibt viele Funktionen, die manche Sachen schneller machen:

memcmp
memcpy
memmove
memset

=======================================================

std::vector

== Container
== Iterator
== Algorithmus

=======================================================

Filtern:

a) Geht
b) Umständlicher 

=======================================================

Lotto spielen ....

Zufallszahlen ...


Liefert std::rand eine Zufallszahl zurück ???

Ja, schon, aber diese wird berechnet.

A) Wenn ich mit der Vorbelegung des Zufallszahlengenerators arbeite:

   Immer diesselbe Folge berechnet: Kann ein Vorteil sein.

                         Reproduktion von Abstürzen.

B) Mit einem Startwert // Jargon: Samen (seed) arbeiten

==============================================================

Lotto spielen:

Ziel:

Umgang mit der STL:
-------------------

Umgang mit OO:
______________

class Lottery

Ziehung der Lottozahlen simulieren.

1. Zahl gezogen ...
2. Zahl gezogen ...

class Lottery:

Kugeln im Bereich von 1 .. 49

  "has-a":   std::vector mit den gezogenen Kugeln / Zahlen

  Zu Beginn leer:

  Methode: drawNextNumber

  std::vector hat dann ein Element

  Methode: drawNextNumber

  Hürde  // Stolperfalle:

     Hmmm: Die zweite gezogene Zahl (std::rand) darf nicht im vector vorhanden sein !!!!!!

     std::find  // std::find_if 

  print: Ausgabe der bereits gezogenen Kugeln.

=================================================

STL: Container:   std::vector

Container eines anderes Aussehens:

Hash Tabelle:
-------------

Dictionary

Worum geht's:

Daten:    Struktur:

Ersten Wert:   Name einer Person
Zweiten Wert:  Telefonnummer

1. Ansatz:  

Klasse Eintrag // Entry // Contact:

class Contact
{
    std::string m_name;   // Name
    size:t      m_phone;  // Nummer
};

Vektor mit vielen Contact-Einträgen / Contact-Elementen erzeugen.

PROBLEM:

Vektor mit vielen Contact-Einträgen :  1.000 Einträge

Anfrage: Suche nach "Hans Meier" zB der 999 Eintrag.

Neuer Ansatz:

Tabellen:  2 Einträge:  (Schlüssel / Wert) //  (Key / Value)

"Hans Meier": Schlüssel
12312321:     Wert
 
Tabellen verwalten (Schlüssel / Wert) - Paare.

Hashtabelle:

Idee: Man berechne zu einem Schlüssel einen INDEX.

"Peter Wagner" ===> INDEX  (254)     // Hash-Funktionen

Dieses Index zeigt in eine Tabelle (Vektor):

// Pointer auf das unterlagerte (Schlüssel / Wert) - Paar.

Problem:   Hash - Kollision

Tina Meier   ==> 152
Hans Mueller ==> 152

Lösung:

// Pointer auf eine LISTE mit unterlagerten (Schlüssel / Wert) - Paaren.

C++ STL:   std::unorderer_map

VORSICHT:  std::map  // Ist was anderes // Binärer Suchbaum.

Ideen:

Wie kann man sich eine Hash-Funktion vorstellen:

"Peter Wagner" ==> Summer aller Ascci Werte: ( 61 + 66 + 89 + ... ) % 255 .

Telefonbuch:

Hash ==> streuen // verstreuen:  Dünger wird verstreut: gleichmäßig.


    std::unordered_map<std::string, size_t> m_book; 

Wie sieht ein Eintrag ((Schlüssel / Wert)- Paar) in der Praxis aus?

std::pair:

// ====================================================================

Übung zum Phonebook:
--------------------

Das haben wir:

class Phonebook
{
private:
    std::unordered_map<std::string, size_t> m_book;   // Hash-Tabelle

public:
    bool addEntry(const std::string& name, size_t phone);
    bool searchEntry(const std::string& name);
    bool getPhonenumber(const std::string& name, size_t& phone);
};

NEU:

getter:

   int countEntries();  // Wieviele Einträge hat das Phonebook

Methode:

   void print();        // Den Inhalt des Phonebooks ausgeben.

Etwas komplizierter // Online:

Einen Eintrag entfernen:

    bool removeEntry (const std::string& name);

    // true : hat geklappt

    // false: hat nicht geklappt.

// ======================================================

Eingabe // Ausgabe:
-------------------

std::cout:   character output

Ausgabe in die Konsole.

Idee des Operators <<:

Operator <<:


Unterschied von

std::cout << "Eine Zeile" << std::endl;
// es wird ein Zeichen in den internen Puffer von std::cout geschrieben
// UND der Puffer wird ge-flushed // geleert // Also die Konsole aktualisiert. 

und

std::cout << "Eine Zeile" << '\n';
// es wird ein Zeichen in den internen Puffer von std::cout geschrieben.

Datei:  std::fstream  // Datei.

=========================================================

Ziel:

    std::cout << myBook << std::endl;

Lösung: operator << überladen

Typ / Argument links:  std::ostream
Typ / Argument rechts: Phonebook

Da links ein  std::ostream-Objekt (std::cout) erwartet wird,
muss operator<< als GLOBALE FUNKTION realisiert werden.

Fehlermeldung:

unresolved external symbol

"void __cdecl operator<<(class std::basic_ostream<char,struct std::char_traits<char> > &,
class Phonebook const &)" 

(??6@YAXAEAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AEBVPhonebook@@@Z) 

referenced in function "void __cdecl phone_book(void)" (?phone_book@@YAXXZ)

Überladen  von Operatoren:

operator<<


Fehler

'<<': not valid as left operand has type 'void'

================================================================

Meine Klasse hat einen Namen:  Textbox.

Hmmm, kann es da zu Konflikten kommen???

Der Name könnte ja schon vergeben sein.

Antwort:

Man füge die Klasse in einen Namensraum ein:

namespace MyProject
{
    class Textbox
    {
    };
}

Folge:

Der Name der Klasse hat sich geändert:

MyProject::Textbox  

Konsequenz:

Will an anderer Stelle diese Klasse verwenden: ==> Textbox

// =============================================================

Aufrufbare Objekte

C++   Vorliebe für Operatoren

Iteratoren:  

++,
*,
==, !=

Ausgabe:  << 

C#:

++        => next
*         => Current
==, !=    =>Equals


=======================================================

Classic  C++
------------

==>

Modern C++ // C++ 11
--------------------

Der rote Faden // Überblick  ===> Agenda

Erster Umstieg von Classic C++ nach Modern C++

== auto
== Lamba
== Brace Init

=======================================================

== auto

Go for auto

    static decltype ( std::declval<T>() + std::declval<U>() ) 


Stackoverflow:    

    std::declval  ====> decltype  ===> Typ definiert ..mit Template Parametern



============================================================

Vorsicht:

warning C4172: returning address of local variable or temporary : tmp

============================================================

Neue Syntax der Initialisierung:
--------------------------------

https://github.com/pelocpp/cpp_modern/blob/master/GeneralSnippets/BraceInitialization/BraceInitialization.md

Hinweis:

        int intArray7[10]{ };   // <========== Vorbelegung mit NULL-Wert
00007FF6B45363F9  lea         rax,[intArray7]  
00007FF6B4536400  mov         rdi,rax  
00007FF6B4536403  xor         eax,eax  
00007FF6B4536405  mov         ecx,28h    // ist 40 Bytes == 10 int // 1 int == 4 byte
00007FF6B453640A  rep stos    byte ptr [rdi]  

=========================================================

Lambdas
=======

https://github.com/pelocpp/cpp_modern/blob/master/GeneralSnippets/Lambda/Lambda.md

Was ist ein Lambda ???

Umgangsprachlich: eine anonyme Funktion
Exakt:            ein Objekt einer Klasse, deren Defintion vor uns versteckt ist.

                  ein Objekt einer anonymen Klasse

Modern C++ ==> Classic C++ Konzepte

Historisch:

std::sort  // STL

== Container sortieren

== Zum Vergleichen der Elemente / Objekte:

   "Dritte" Parameter:

   a) globale Funktion // OO ;(  // diese steht im Quellcode woanders ...

   b) Aufrufbares Objekt         // Bessere OO

   c) Was ist ein Lambda:        Ein aufrufbares Objekt , mit einer anderen Syntax!

                 Neue Syntax:  Der STL-Algorithmus und die notwendige Funktion
                               stehen an derselben Stelle.

                               Übersichtlichkeit

// ====================================================================

Tool  Cpp Insights

Ist kein Online-Compiler (  C++ ==> Maschinencode + Ausführung)

sondern: Prä-Compiler:

C++ - Quelltext in Modern C++ Schreibweise ==> C++ - Quelltext in Classic C++ Schreibweise

Will ich C++ und Lambdas wirklich verstehen: Dann ja.

1. Feature von Lambdas:

Lokale Variablen aus dem umgebenden Scope
können im Lambda-Objekt verwendet // angesprochen werden:

Wie ???

a) als Kopie

b) als Referenz - Zugriff auf das Original.

Wozu:

Naja, sind die  Variablen aus dem umgebenden Scope GROSS,
dann kann man Kopien vermeiden.

Frage:

https://github.com/pelocpp/cpp_modern/blob/master/GeneralSnippets/Lambda/Lambda.md

========================================================================

Lambdas:

Exakt:  Es sind Objekte - von einer Klasse, deren Typ wir nicht sehen.

Was haben Objekte:

Instanzvariablen.

Hmm, können dann Lambda-Objekte auch Instanzvariablen haben ????

Yes.

========================================================================

Anwendung von Lambdas:

ZB bei Algorithmen.

========================================================================

Wenn man "das" mal sieht:

Starthilfe --- um auf die nächste Treppenstufe zu gelangen.

========================================================================

Frage:

    // classic
    std::for_each(
        numbers.begin(),
        numbers.end(),
        print
    );

    // modern / kompakt
    std::for_each(
        numbers.begin(),
        numbers.end(),
        [] (int value) { std::cout << value << std::endl; }
    );

Technisch gesehen tut das dasselbe ..................

Könnte die Variante mit dem Lambda einen Vorteil haben ???

95%:  Lambda's können vom Compiler // Code-Generator "inline" abgesetzt werden:

      ==> Performanz-Vorteil ist möglich.

=======================================================================

Übung:

https://github.com/pelocpp/cpp_modern/blob/master/GeneralSnippets/Exercises/Exercises_02_Lambdas.md



Aufgabe 1: Gerade oder ungerade // teilbar oder nicht teilbar

Aufgabe 3: Quiz mit Lambda-Funktionen

Quiz 1
Quiz 2


Warum nicht 3 und / oder 4: Da sind nochmal "Subtile" Stolperfallen drin,
da ergibt heute keinen Sinn / generell selten einen Sinn.






